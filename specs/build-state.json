{
  "lastSpec": "P1-17",
  "completed": ["P1-01", "P1-02", "P1-03", "P1-04", "P1-05", "P1-06", "P1-07", "P1-08", "P1-09", "P1-10", "P1-11", "P1-12", "P1-13", "P1-14", "P1-15", "P1-16", "P1-17"],
  "currentPillar": 1,
  "totalSpecs": 83,
  "patternsEstablished": [
    "dict[str, Any] for all unparameterized dicts",
    "type: ignore[attr-defined] for SDK imports without __all__",
    "pydantic_settings.BaseSettings for centralized config",
    "@lru_cache(maxsize=1) + get_settings() for config singleton",
    "get_settings.cache_clear() in tests for isolation",
    "structlog.get_logger(name) for all module-level loggers",
    "structlog.contextvars for correlation_id propagation",
    "ProcessorFormatter.wrap_for_formatter as final structlog processor",
    "try/finally with clear_correlation_id() at request boundaries",
    "_CONFIGURED flag reset in conftest.py for test isolation",
    "SecondBrainError base class with to_dict() serialization",
    "Defensive dict copy in error context attributes",
    "raise TypedError(...) from e for exception chaining in recall.py",
    "get_args(Literal) to derive validation sets from type definitions",
    "DROP CONSTRAINT IF EXISTS + ADD CONSTRAINT for migration pattern",
    "Pure comparison functions for drift detection (no DB dependency)",
    "Strict regex for migration filename parsing",
    "SchemaError with structured context for drift reporting",
    "Protocol-based executor for DB abstraction in tests",
    "Race condition fallback in upsert: try insert, on failure re-query and treat as duplicate (unique constraint is authoritative guard)",
    "Advisory lock (int key) before state reads",
    "MigrationResult model for structured operation feedback",
    "importlib.util for importing standalone scripts in tests",
"Regex-based SQL policy checker with allowed/blocked pattern categories",
    "CircuitBreaker with single-probe HALF_OPEN enforcement",
    "Create trigger BEFORE backfill UPDATE in migrations — closes race window for concurrent inserts during migration",
    "Thread-safe metrics via lock context manager",
    "Executor-first pattern in transaction context managers: call executor before mutating state",
    "Thread-safe mock executor with threading.Lock for concurrent write tests",
    "FK ON DELETE RESTRICT for knowledge_relationships FKs to knowledge_entities; CASCADE only for owned/child rows",
    "frozenset of (from, to) tuples for state machine transition validation",
    "ChunkNotFoundError vs StaleDataError: not-found (404) and version-mismatch (409) are distinct exception types"
  ],
  "decisionsLog": [
    {
      "spec": "P1-01",
      "decision": "Use dict[str, Any] not TypedDict for model_dump() outputs and metadata dicts",
      "reason": "Accurate typing without premature TypedDict definitions — stronger typing deferred to dedicated specs"
    },
    {
      "spec": "P1-01",
      "decision": "type: ignore[attr-defined] for voyageai.Client, not a type stub",
      "reason": "Minimal maintenance burden, voyageai may publish stubs later"
    },
    {
      "spec": "P1-02",
      "decision": "All Settings fields optional with defaults, no eager validation at module level",
      "reason": "Tests run without .env file; lru_cache singleton validates on first get_settings() call"
    },
    {
      "spec": "P1-02",
      "decision": "Scope config.py to deps.py only, service files keep os.getenv fallback",
      "reason": "Service files have direct instantiation paths for testing; centralizing everything in one spec increases risk"
    },
    {
      "spec": "P1-03",
      "decision": "structlog with ProcessorFormatter for JSON rendering, not dual JSONRenderer",
      "reason": "Avoids double JSON rendering bug — structlog processors prepare dict, ProcessorFormatter renders once"
    },
    {
      "spec": "P1-03",
      "decision": "Conditional correlation_id set in planner (preserve upstream ID)",
      "reason": "MCP server sets request-level correlation_id; planner only sets if none exists to avoid overwriting"
    },
    {
      "spec": "P1-03",
      "decision": "unbind_contextvars for cleanup, not clear_contextvars",
      "reason": "clear_contextvars wipes ALL structlog contextvars; unbind only removes correlation_id key"
    },
    {
      "spec": "P1-04",
      "decision": "Narrow scope: only errors.py, recall.py, planner.py modified. Services keep swallow+degrade pattern",
      "reason": "Services intentionally catch exceptions internally for resilience. Adding typed raises would break graceful degradation."
    },
    {
      "spec": "P1-04",
      "decision": "Planner catches (SecondBrainError, ValidationError) instead of 5 manual exception types",
      "reason": "SecondBrainError covers all typed errors from recall.py; ValidationError needed for Pydantic RetrievalRequest construction"
    },
    {
      "spec": "P1-05",
      "decision": "Derive _VALID_SOURCE_ORIGINS via get_args(SourceOriginValue) instead of hardcoded set",
      "reason": "Eliminates triple-definition drift risk — single source of truth in Literal type"
    },
    {
      "spec": "P1-06",
      "decision": "SchemaManager uses pure functions: scan_migrations (filesystem), detect_drift (comparison), validate_schema_integrity (orchestrator)",
      "reason": "Testable without DB. Core logic is pure Python comparison. DB integration deferred to migration-runner spec (P1-07)."
    },
    {
      "spec": "P1-07",
      "decision": "MigrationExecutor as Protocol (structural typing), not ABC",
      "reason": "Protocol enables duck typing — any object with matching methods works. No inheritance needed for mock in tests."
    },
    {
      "spec": "P1-10",
      "decision": "Create pool.py as standalone, don't refactor supabase.py yet",
      "reason": "Pool is ready to integrate but forcing replacement of existing supabase.py client management increases risk. Integration deferred."
    },
    {
      "spec": "P1-11",
      "decision": "Executor-first pattern: call executor before mutating state in TransactionManager",
      "reason": "If executor raises after state mutation, state is left inconsistent AND except block re-raises IndexError hiding original exception. Peek-then-pop on exit prevents double-pop."
    },
    {
      "spec": "P1-12",
      "decision": "MockChunkWriteExecutor lives in test file, not service file",
      "reason": "Production service files should not contain test helpers. Protocol-based executor abstraction allows mocks to live in tests without polluting service modules."
    },
    {
      "spec": "P1-13",
      "decision": "ON DELETE RESTRICT for knowledge_relationships FKs to knowledge_entities",
      "reason": "Relationships reference entities but don't own them. CASCADE would silently delete all relationships when an entity is deleted. RESTRICT forces explicit cleanup."
    },
    {
      "spec": "P1-14",
      "decision": "Catch insert exception and retry as find-then-update for race condition safety",
      "reason": "find_by + insert is not atomic. Under concurrent load two writers can both see None and race to insert. DB unique index is the true guard; Python layer catches the violation and falls back to update path."
    },
    {
      "spec": "P1-15",
      "decision": "superseded→active transition intentionally blocked",
      "reason": "Superseded means explicitly replaced by re-ingestion. Direct reinstatement bypasses audit trail. Restore path is: new re-ingestion (not state flip)."
    },
{
      "spec": "P1-16",
      "decision": "Separate ChunkNotFoundError from StaleDataError",
      "reason": "CHUNK_NOT_FOUND and STALE_VERSION are fundamentally different: not-found means no retry, stale means re-fetch-and-retry. Conflating them forces callers to string-match error codes."
    },
    {
      "spec": "P1-17",
      "decision": "Trigger on UPDATE OF content only, not all column updates",
      "reason": "content_tsv is derived solely from content. Metadata/status/version updates don't require tsvector refresh — UPDATE OF content correctly scopes the trigger."
    }
  ]
}
